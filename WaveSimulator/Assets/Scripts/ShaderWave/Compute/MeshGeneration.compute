#pragma kernel GerstnerWaveChunkGenerator 0
#pragma kernel TriangleSetup 1

#define THREAD_GROUP_SIZE_X 32
#define THREAD_GROUP_SIZE_Y 1
#define THREAD_GROUP_SIZE_Z 32

RWStructuredBuffer<float3> verticesOutput;  // Structured buffer to hold the vertices of the mesh
RWStructuredBuffer<float2> uvOutput;        // Structured buffer to hold the UV coordinates of the mesh
RWStructuredBuffer<int> triangleOutput;     // Structured buffer to hold the triangle indices of the mesh
RWStructuredBuffer<float3> wave_time_chunk;

#define PI 3.14159265358979323846
#define GRAVITY 9.80665

float4 wave_params_array[2500];
float2 wave_chunk[10];
int wave_chunk_array_length;

int mesh_resolution, num_waves, grid_resolution;
float scaling;
float time;
float2 chunkId, grid_shift;
float4 wave_params[2000];
float wave_amplitude_scale;
float wave_time_shift_factor;

// Fast inverse square root function for use in the Gerstner wave function
float fastInvSqrt(float x)
{
    uint i = asuint(x);                         // Convert the float value to an unsigned integer
    i = 0x5f3759df - (i >> 1);                  // Subtract 1 from the integer value and divide by 2
    x = asfloat(i);                             // Convert the integer back to a float
    x = x * (1.5f - x * x * 0.5f * x);          // Use the Newton-Raphson method to approximate the inverse square root
    return x;
}


float3 calculate_gerstner_wave(float3 position, int start, int end, int wave_amount, float3 wave_time)
{
    float3 displacement = float3(0,0,0);

    float wave_time_current = wave_time.x;
    
    for(int i = start; i < end; i++)
    {
        // Extract wave parameters for the current wave
        float4 current_wave_params = wave_params_array[i];
        
        // Calculate the steepness, wavelength, and wave number
        const float steepness = current_wave_params.z;
        const float wavelength = current_wave_params.w;

        if(current_wave_params.x == 0 && current_wave_params.y == 0) continue;
        if(steepness <= 0 || wavelength <= 0) continue;

        // 
        const float k = 2 * PI / wavelength;
            
        // Calculate the wave speed
        const float c = fastInvSqrt(9.8 / k);

        // Normalize the wave direction
        const float2 direction = normalize(current_wave_params.xy);

        // Calculate the wave phase
        const float f = k * (dot(direction, position.xz - c * wave_time_current));

        // Calculate the wave amplitude
        const float amplitude = steepness / k;
        
        // Calculate the Gerstner wave displacement in the x, y, and z directions
        displacement += float3 (
            amplitude * direction.x * cos(f) / (k * wave_amount),
            amplitude * sin(f),
            amplitude * direction.y * cos(f) / (k * wave_amount));

        wave_time_current +=  wave_time.z;
    }
    
    return displacement;
}


float3 gerstner_wave_calculations(float3 position)
{
    if(wave_chunk[0].x == 0) return float3 (0,0,0);

    float3 total_displacement = float3(0,0,0);
    
    int start_index = 0;
    for(int j = 0; j < wave_chunk_array_length; j++)
    {
        const int current_wave_amount = wave_chunk[j].x;
        const int end_index = start_index + current_wave_amount;

        if(end_index > 2500) break;

        total_displacement += calculate_gerstner_wave(position, start_index, end_index, current_wave_amount, wave_time_chunk[j]);

        start_index = end_index;
    }

    return total_displacement;
}


float3 gerstner_wave (float3 position)
{
    if(num_waves == 0) return float3 (0,0,0);

    
    float3 total_displacement = float3 (0,0,0);
    float3 current_position = position;
    float start_time = time;
    
    for (int i = 0; i < num_waves; i++)
    {
        // Extract wave parameters for the current wave
        float4 current_wave_params = wave_params[i];
        
        // Calculate the steepness, wavelength, and wave number
        const float steepness = current_wave_params.z / num_waves;
        const float wavelength = current_wave_params.w;
        const float k = 2 * PI / wavelength;


        // Calculate the wave speed
        const float c = fastInvSqrt(9.8 / k);

        // Normalize the wave direction
        const float2 direction = normalize(current_wave_params.xy);

        // Calculate the wave phase
        const float f = k * (dot(direction, current_position.xz - c * start_time));

        // Calculate the wave amplitude
        const float amplitude = steepness / k;
        
        // Calculate the Gerstner wave displacement in the x, y, and z directions
        const float3 displacement = float3(
            amplitude * direction.x * cos(f) / (k * num_waves),
            amplitude * sin(f),
            amplitude * direction.y * cos(f) / (k * num_waves));
        
        // Add the displacement to the total displacement
        total_displacement += displacement * wave_amplitude_scale;
        
        // Update the current position by adding the displacement
        current_position += displacement;

        start_time += wave_time_shift_factor;
    }
    
    return total_displacement;
}

void MeshChunkGeneration(uint3 id, float vertexCount)
{
    for(int x = 0; x < chunkId.x; x++)
    {
        for(int z = 0; z < chunkId.y; z++)
        {
            float3 pos = id;
            
            // Offset the position by the chunk ID
            pos.x += (x * 32);
            pos.z += (z * 32);

            // Skip iterations if the vertex position is outside the mesh resolution
            if(pos.x >= mesh_resolution || pos.z >= mesh_resolution) continue;

            const int vertex_index = pos.x + pos.z * mesh_resolution;
            
            // Skip iterations if the vertex index is invalid
            if(vertex_index > vertexCount) continue;

            // Grid shift
            pos.x += grid_shift.x;
            pos.z += grid_shift.y;
            
            pos.x *= scaling;
            pos.z *= scaling;

            // Static 5 so the null point is in the centre
            pos.xz -= 5;
            
            float3 displacement = gerstner_wave_calculations(pos);
            pos += displacement;

            // UV
            const float2 caustic_tex_coords = float2 (pos.x / (scaling * mesh_resolution), pos.z / (scaling * mesh_resolution)) + displacement.xy * 0.0001f;
                        
            verticesOutput[vertex_index] = pos;
            uvOutput[vertex_index] = caustic_tex_coords;
        }
    }
}


[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void GerstnerWaveChunkGenerator(uint3 id : SV_DispatchThreadID)
{  
    // Skip iterations if the thread ID is invalid
    if(id.x > THREAD_GROUP_SIZE_X || id.y > THREAD_GROUP_SIZE_Y || id.z > THREAD_GROUP_SIZE_Z) return;

    // Calculate the mesh vertex count
    const float vertexCount = mesh_resolution * mesh_resolution;

    MeshChunkGeneration(id, vertexCount);
}

// Sets up the triangle indices for each vertex
[numthreads(32, 1, 32)]
void TriangleSetup(uint3 id : SV_DispatchThreadID)
{  
    if(id.x > THREAD_GROUP_SIZE_X || id.y > THREAD_GROUP_SIZE_Y || id.z > THREAD_GROUP_SIZE_Z) return;

    for(int x = 0; x < chunkId.x; x++)
    {
        for(int z = 0; z < chunkId.y; z++)
        {
            float3 index = id;
            index.x += (x * 32);
            index.z += (z * 32);
            
            if(index.x < mesh_resolution - 1 && index.z < mesh_resolution - 1)
            {
                int triangleIndex = (index.x + (mesh_resolution - 1) * index.z) * 6;

                triangleOutput[triangleIndex++] = (index.x) + mesh_resolution * (index.z);
                triangleOutput[triangleIndex++] = (index.x) + mesh_resolution * (index.z + 1);
                triangleOutput[triangleIndex++] = (index.x + 1) + mesh_resolution * (index.z + 1);

                triangleOutput[triangleIndex++] = (index.x + 1) + mesh_resolution * (index.z + 1);
                triangleOutput[triangleIndex++] = (index.x + 1) + mesh_resolution * (index.z);
                triangleOutput[triangleIndex] = (index.x) + mesh_resolution * (index.z);
            }
        }
    }
}