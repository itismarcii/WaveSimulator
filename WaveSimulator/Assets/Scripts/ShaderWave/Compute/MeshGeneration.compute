#pragma kernel GerstnerWaveChunkGenerator 0
#pragma kernel TriangleSetup 1

#define THREAD_GROUP_SIZE_X 32
#define THREAD_GROUP_SIZE_Y 1
#define THREAD_GROUP_SIZE_Z 32

RWStructuredBuffer<float3> verticesOutput;  // Structured buffer to hold the vertices of the mesh
RWStructuredBuffer<float2> uvOutput;        // Structured buffer to hold the UV coordinates of the mesh
RWStructuredBuffer<int> triangleOutput;     // Structured buffer to hold the triangle indices of the mesh

#define PI 3.14159265358979323846

struct WaveInformation
{
    float2 direction;
    float amplitude;
    float steepness;
    float wavelength;
};

struct WaveGeneratorInformation
{
    WaveInformation wave_information[100];
    int wave_amount;
};

WaveGeneratorInformation wave_generation_information[10];

int mesh_resolution, num_waves, grid_resolution;
float scaling;
float time;
float2 chunkId;
float4 wave_params[2000];
float wave_amplitude_scale;
float wave_time_shift_factor;

// Fast inverse square root function for use in the Gerstner wave function
float fastInvSqrt(float x)
{
    uint i = asuint(x);                         // Convert the float value to an unsigned integer
    i = 0x5f3759df - (i >> 1);                  // Subtract 1 from the integer value and divide by 2
    x = asfloat(i);                             // Convert the integer back to a float
    x = x * (1.5f - x * x * 0.5f * x);          // Use the Newton-Raphson method to approximate the inverse square root
    return x;
}


float3 gerstner_wave (float3 position)
{
    if(num_waves == 0) return float3 (0,0,0);
    
    float3 total_displacement = float3 (0,0,0);
    float3 current_position = position;
    float startTime = time;
    
    for (int i = 0; i < num_waves; i++)
    {
        // Extract wave parameters for the current wave
        float4 current_wave_params = wave_params[i];
        
        // Calculate the steepness, wavelength, and wave number
        const float steepness = current_wave_params.z;
        const float wavelength = current_wave_params.w;
        const float k = 2 * PI / wavelength;


        // Calculate the wave speed
        const float c = fastInvSqrt(9.8 / k);

        // Normalize the wave direction
        const float2 direction = normalize(current_wave_params.xy);

        // Calculate the wave phase
        const float f = k * (dot(direction, current_position.xz - c * startTime));

        // Calculate the wave amplitude
        const float amplitude = steepness / k;
        
        // Calculate the Gerstner wave displacement in the x, y, and z directions
        float3 displacement = float3(
            amplitude * direction.x * cos(f) / (k * num_waves),
            amplitude * sin(f),
            amplitude * direction.y * cos(f) / (k * num_waves));
        
        // Add the displacement to the total displacement
        total_displacement += displacement * wave_amplitude_scale;
        
        // Update the current position by adding the displacement
        current_position += displacement;

        startTime += wave_time_shift_factor;
    }
    
    return total_displacement;
}

void MeshChunkGeneration(uint3 id, float vertexCount)
{
    for(int x = 0; x < chunkId.x; x++)
    {
        for(int z = 0; z < chunkId.y; z++)
        {
            float3 pos = id;
            
            // Offset the position by the chunk ID
            pos.x += (x * 32);
            pos.z += (z * 32);

            // Skip iterations if the vertex position is outside the mesh resolution
            if(pos.x >= mesh_resolution || pos.z >= mesh_resolution) continue;

            int vertexIndex = pos.x + pos.z * mesh_resolution;
            
            // Skip iterations if the vertex index is invalid
            if(vertexIndex > vertexCount) continue;

            pos.x *= scaling;
            pos.z *= scaling;

            // Static 5 so the null point is in the centre
            pos.x -= 5;
            pos.z -= 5;
            
            float3 displacement = gerstner_wave(pos);
            pos += displacement;

            float2 causticTexCoords = float2 (pos.x / (scaling * mesh_resolution), pos.z / (scaling * mesh_resolution)) + displacement.xy * 0.0001f;

            verticesOutput[vertexIndex] = pos;
            uvOutput[vertexIndex] = causticTexCoords;
        }
    }
}


[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void GerstnerWaveChunkGenerator(uint3 id : SV_DispatchThreadID)
{  
    // Skip iterations if the thread ID is invalid
    if(id.x > THREAD_GROUP_SIZE_X || id.y > THREAD_GROUP_SIZE_Y || id.z > THREAD_GROUP_SIZE_Z) return;

    // Calculate the mesh vertex count
    const float vertexCount = mesh_resolution * mesh_resolution;

    MeshChunkGeneration(id, vertexCount);
}

// Sets up the triangle indices for each vertex
[numthreads(32, 1, 32)]
void TriangleSetup(uint3 id : SV_DispatchThreadID)
{  
    if(id.x > THREAD_GROUP_SIZE_X || id.y > THREAD_GROUP_SIZE_Y || id.z > THREAD_GROUP_SIZE_Z) return;

    for(int x = 0; x < chunkId.x; x++)
    {
        for(int z = 0; z < chunkId.y; z++)
        {
            float3 index = id;
            index.x += (x * 32);
            index.z += (z * 32);
            
            if(index.x < mesh_resolution - 1 && index.z < mesh_resolution - 1)
            {
                int triangleIndex = (index.x + (mesh_resolution - 1) * index.z) * 6;

                triangleOutput[triangleIndex++] = (index.x) + mesh_resolution * (index.z);
                triangleOutput[triangleIndex++] = (index.x) + mesh_resolution * (index.z + 1);
                triangleOutput[triangleIndex++] = (index.x + 1) + mesh_resolution * (index.z + 1);

                triangleOutput[triangleIndex++] = (index.x + 1) + mesh_resolution * (index.z + 1);
                triangleOutput[triangleIndex++] = (index.x + 1) + mesh_resolution * (index.z);
                triangleOutput[triangleIndex++] = (index.x) + mesh_resolution * (index.z);
            }
        }
    }
}