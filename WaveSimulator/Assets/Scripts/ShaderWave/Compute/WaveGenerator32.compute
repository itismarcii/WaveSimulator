#pragma kernel wave_generator
#pragma kernel uv_generator;
#pragma kernel triangle_generator

#define PI 3.14159265358979323846

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float2> uvs;
RWStructuredBuffer<int> triangles;

uint resolution;
float4 wave0, wave1, wave2, wave3, wave4, wave5;
float3 shift;
float time, scaling;
float4 time_shift[1000];
float4 waves[1000], startIndex;
int waves_length;

float3 gerstner_wave (float4 wave, float3 position)
{
    if(wave.z == 0 || wave.w == 0) return float3 (0,0,0);
    
    const float steepness = wave.z;
    const float wavelength = wave.w;
    const float k = 2 * PI / wavelength;
    const float c = sqrt(9.8 / k);
    const float2 d = normalize(wave.xy);
    const float f = k * (dot(d, position.xz) - c * time);
    const float a = steepness / k;

    return float3(
        a * cos(f),
        a * sin(f),
        a * cos(f));
}

float2 hash(in float2 x)
{
    const float2 k = float2( 0.3183099, 0.3678794);
    x = x * k + k.yx;
    return -1.0 + 2.0*frac(16.0 * k * frac(x.x * x.y * (x.x + x.y)));
}

float mix(float x, float y, float a)
{
    return x * (1-a) + y * a;
}

float noise_coordinate(float3 coordinate)
{
    const float kF = 2.0f;
    
    float2 pos = coordinate.xz;

    float2 i = floor(pos);
    float2 f = frac(pos);

    f = f * f * (3.0 - 2.0 * f);
    
    return mix(
        mix(
            sin(kF * dot(pos, hash(i + float2(0.0,0.0)))),
            sin(kF * dot(pos, hash(i + float2(1.0,0.0)))),
            f.x),
        mix(
            sin(kF * dot(pos, hash(i + float2(0.0,1.0)))),
            sin(kF * dot(pos, hash(i + float2(1.0,1.0)))),
            f.x),
        f.y);
}

[numthreads(32,1,32)]
void wave_generator (uint3 id : SV_DispatchThreadID)
{   
    if(id.x < resolution && id.z < resolution)
    {
        float3 pos = id.xyz;
        
        pos.x += startIndex.x;
        pos.z += startIndex.y;
        
        for (int i = 0; i < waves_length; ++i)
        {
            time += time_shift[i].x;
            pos += gerstner_wave(waves[i], pos);
            pos.y += 0.0025 * noise_coordinate(pos);
            pos.y += 0.00125 * noise_coordinate(pos);
            pos.y += 0.000625 * noise_coordinate(pos);
            pos.y += 0.00003125 * noise_coordinate(pos);
        }
        
        pos.x += shift.x;
        pos.z += shift.z;
        
        pos.x *= scaling;
        pos.y *= scaling;
        pos.z *= scaling;

        normalize(pos);
        vertices[id.x + id.z * resolution] = pos;
    }
}

[numthreads(32,1,32)]
void uv_generator (uint3 id : SV_DispatchThreadID)
{
    uvs[id.x + id.z * resolution] = float2 (id.x / resolution, id.z / resolution);
}

[numthreads(32,1,32)]
void triangle_generator (uint3 id : SV_DispatchThreadID)
{
    if(id.x < resolution - 1 && id.z < resolution - 1)
    {
        int index = (id.x + (resolution - 1) * id.z) * 6;

        triangles[index++] = (id.x) + resolution * (id.z);
        triangles[index++] = (id.x) + resolution * (id.z + 1);
        triangles[index++] = (id.x + 1) + resolution * (id.z + 1);

        triangles[index++] = (id.x + 1) + resolution * (id.z + 1);
        triangles[index++] = (id.x + 1) + resolution * (id.z);
        triangles[index++] = (id.x) + resolution * (id.z);
    }
}
